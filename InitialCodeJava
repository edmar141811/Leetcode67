/*
Will have to improve code and clean up comments in the future
time and space both need improvement

Runtime 4 ms
Beats 14.44%

Memory
48.06 MB
Beats 5.05%
*/
class Solution {
    public String addBinary(String a, String b) {
                //initialization of variables and declaration
        int maxSize = 0;
        int checkSize = 0;
        int soloSize = 0;
        int trackSize = 0;
        int adder=0;
        int futureAdd=0;
        char tempA;
        char tempB;
        String longest;
        String c ="";
        //checking which is string is biggest and initialization of previous variables
        if(a.length()>b.length()){
            maxSize = a.length()+1;
            checkSize = b.length();
            soloSize = a.length() - b.length();
            trackSize = a.length()-1;
            longest = a;
        }
        else {
            maxSize = b.length() +1;
            checkSize = a.length();
            soloSize = b.length() - a.length();
            trackSize = b.length()-1;
            longest = b;
        }
        //goes throught the size that matches the smallest
        while(0 < checkSize){
            tempA = a.charAt(a.length()-1);
            tempB = b.charAt(b.length()-1);
            //cout << tempA<< " "<< tempB << endl;
            //checking if there is carry over to add
            if(futureAdd > 0){
                adder = futureAdd;
                futureAdd = 0;
            }
            //deciding bit
            if(tempA == '1'){
                //cout << "enter";
                adder++;
            }
            if(tempB == '1'){
                //cout << "enter";
                adder++;
            }
            adder = futureAdd + adder;
            //cout << adder << endl;
            //giving the value and potential carry over
            if(adder>0){
                //cout << "enter";
                if(adder==1){
                    //c.insert (0, 1, '1');
                    c = '1' + c;
                    adder=0;
                }
                else if(adder==2){
                    //c.insert (0, 1, '0');
                    c = '0' + c;
                    futureAdd++;
                    adder=0;
                }
                else{
                    //c.insert (0, 1, '1');
                    c = '1' + c;
                    futureAdd++;
                    adder=0;
                }
                //a.erase(a.length()-1,1);
                a = a.substring(0, a.length() - 1);
                //b.erase(b.length()-1,1);
                b = b.substring(0, b.length() - 1);
            }
            else{
                //c.insert (0, 1, '0');
                c = '0' + c;
                //a.erase(a.length()-1,1);
                a = a.substring(0, a.length() - 1);
                //b.erase(b.length()-1,1);
                b = b.substring(0, b.length() - 1);
            }
            checkSize--;
        }
        //just to keep longest 
        if(a.length()>b.length()){
            longest = a;
        }
        else{
            longest = b;
        }
      //doing the math on the remaining string left
        while(0 < soloSize){
            //cout << longest.back() << endl;
            //tempA = longest.back();
            tempA = longest.charAt(longest.length()-1);
            if(futureAdd>0){
                adder= futureAdd;
                futureAdd = 0;
            }
            if(tempA == '1'){
                adder++;
            }
            // redoing the carry over plus initial adding
            if(0 < adder){
                if(adder==1){
                    //c.insert(0, "1");
                     c = '1' + c;
                    adder=0;
                }
                else if(adder==2){
                    //c.insert(0, "0");
                    c = '0' + c;
                    futureAdd++;
                    adder=0;
                }
                else{
                    //c.insert(0, "1");
                    c = '1' + c;
                    futureAdd++;
                    adder=0;
                }
                //longest.erase(longest.length()-1,1);
                longest=longest.substring(0, longest.length() - 1);
            }
            else{
                //c.insert (0, 1, '0');
                 c = '0' + c;
                //longest.erase(longest.length()-1,1);
                longest=longest.substring(0, longest.length() - 1);
            }
            soloSize--;
        }
            //incase of final remaining carry
            if(futureAdd>0||adder >0){
                //c.insert (0, 1, '1');
                    c = '1' + c;
                futureAdd = 0;
            }
        return c;
    }
}
