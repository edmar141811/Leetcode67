/*
Runtime 0 ms
Beats 100.00%

Memory 8.35 MB
Beats 99.99%

I think runtime is probably a bit incorrect I feel like their is a faster way for it to be done might retry later
*/
class Solution {
public:
    string addBinary(string a, string b) {
        //initialization of variables and declaration
        int maxSize = 0;
        int checkSize = 0;
        int soloSize = 0;
        int trackSize = 0;
        int adder=0;
        int futureAdd=0;
        char tempA;
        char tempB;
        string longest;
        string c;
        //checking which is string is biggest and initialization of previous variables
        if(a.size()>b.size()){
            maxSize = a.size()+1;
            checkSize = b.size();
            soloSize = a.size() - b.size();
            trackSize = a.size()-1;
            longest = a;
        }
        else {
            maxSize = b.size() +1;
            checkSize = a.size();
            soloSize = b.size() - a.size();
            trackSize = b.size()-1;
            longest = b;
        }
        //goes throught the size that matches the smallest
        while(0 < checkSize){
            tempA = a.back();
            tempB = b.back();
            //cout << tempA<< " "<< tempB << endl;
            //checking if there is carry over to add
            if(futureAdd > 0){
                adder = futureAdd;
                futureAdd = 0;
            }
            //deciding bit
            if(tempA == '1'){
                //cout << "enter";
                adder++;
            }
            if(tempB == '1'){
                //cout << "enter";
                adder++;
            }
            adder = futureAdd + adder;
            //cout << adder << endl;
            //giving the value and potential carry over
            if(adder>0){
                //cout << "enter";
                if(adder==1){
                    c.insert (0, 1, '1');
                    adder=0;
                }
                else if(adder==2){
                    c.insert (0, 1, '0');
                    futureAdd++;
                    adder=0;
                }
                else{
                    c.insert (0, 1, '1');
                    futureAdd++;
                    adder=0;
                }
                a.erase(a.size()-1,1);
                b.erase(b.size()-1,1);
            }
            else{
                c.insert (0, 1, '0');
                a.erase(a.size()-1,1);
                b.erase(b.size()-1,1);
            }
            checkSize--;
        }
        //just to keep longest 
        if(a.size()>b.size()){
            longest = a;
        }
        else{
            longest = b;
        }
      //doing the math on the remaining string left
        while(0 < soloSize){
            //cout << longest.back() << endl;
            tempA = longest.back();
            cout << tempA << endl;
            if(futureAdd>0){
                adder= futureAdd;
                futureAdd = 0;
            }
            if(tempA == '1'){
                adder++;
            }
            // redoing the carry over plus initial adding
            if(0 < adder){
                if(adder==1){
                    c.insert(0, "1");
                    adder=0;
                }
                else if(adder==2){
                    c.insert(0, "0");
                    futureAdd++;
                    adder=0;
                }
                else{
                    c.insert(0, "1");
                    futureAdd++;
                    adder=0;
                }
                longest.erase(longest.size()-1,1);
            }
            else{
                c.insert (0, 1, '0');
                longest.erase(longest.size()-1,1);
            }
            soloSize--;
        }
            //incase of final remaining carry
            if(futureAdd>0||adder >0){
                c.insert (0, 1, '1');
                futureAdd = 0;
            }
        return c;
    }
};
